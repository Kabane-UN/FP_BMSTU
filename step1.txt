module Main where

import Control.Monad (when)
import Control.Monad.Except
  ( ExceptT,
    MonadError (throwError),
    runExceptT,
  )
import Control.Monad.State
  ( MonadIO (liftIO),
    StateT (runStateT),
    gets,
    modify,
  )
import Data.Char (isDigit)
import Data.List (words)
import Data.Map qualified as Map
import Distribution.Compat.Prelude (unless)
import System.Environment (getArgs)
import System.Exit (exitSuccess)
import System.IO (hFlush, stdout)

type Stack = [Int]

type Dictionary = Map.Map String Int

data Token
  = Number Int
  | Word String
  deriving (Show, Eq)

data ForthState = ForthState
  { program :: [Token], -- Вся программа как список токенов
    wordCounter :: Int, -- Текущая позиция в программе
    stack :: Stack -- Стек данных
  }
  deriving (Show)

type ForthM = ExceptT String (StateT ForthState IO)

initialState :: ForthState
initialState =
  ForthState
    { program = [],
      wordCounter = 0,
      stack = []
    }

builtins :: Dictionary
builtins =
  Map.fromList
    [ ("+", 1),
      ("-", 2),
      ("*", 3),
      ("/", 4),
      ("mod", 5),
      ("dup", 6),
      ("drop", 7),
      ("swap", 8),
      ("over", 9),
      ("negate", 10),
      (".", 11),
      (".s", 12),
      ("bye", 13)
    ]

interpretProgram :: String -> ForthM ()
interpretProgram input = do
  let tokens = parseTokens input
  let programWithHalt = tokens
  modify $ \s -> s {program = programWithHalt, wordCounter = 0}
  interpret

interpret :: ForthM ()
interpret = do
  state <- gets id
  let tokens = program state
  let counter = wordCounter state

  when (counter < length tokens) $ do
    let token = tokens !! counter
    handleExecution token
  where
    handleExecution :: Token -> ForthM ()
    handleExecution token = do
      case token of
        Number n -> do
          modify $ \s -> s {stack = n : stack s, wordCounter = wordCounter s + 1}
          interpret
        Word w -> do
          case Map.lookup w builtins of
            Just idx -> do
              executeBuiltin idx
              newState <- gets id
              modify $ \s -> s {wordCounter = wordCounter newState + 1}
              interpret
            Nothing -> throwError $ "Неизвестное слово: " ++ w


parseTokens :: String -> [Token]
parseTokens input =
  let cleanedInput = removeComments input
      wordsList = splitWords cleanedInput
   in map parseToken wordsList
  where
    splitWords :: String -> [String]
    splitWords = words

    removeComments :: String -> String
    removeComments [] = []
    removeComments ('(' : xs) =
      let afterComment = skipComment 1 xs
       in removeComments afterComment
    removeComments (x : xs) = x : removeComments xs

    skipComment :: Int -> String -> String
    skipComment 0 rest = rest
    skipComment _ [] = []
    skipComment n ('(' : xs) = skipComment (n + 1) xs
    skipComment n (')' : xs) = skipComment (n - 1) xs
    skipComment n (_ : xs) = skipComment n xs

    parseToken :: String -> Token
    parseToken s
      | all isDigit s = Number (read s)
      | head s == '-' && not (null (tail s)) && all isDigit (tail s) =
          Number (read s)
      | otherwise = Word s

executeBuiltin :: Int -> ForthM ()
executeBuiltin idx = case idx of
  1 -> binaryOp (+) -- +
  2 -> binaryOp (-) -- -
  3 -> binaryOp (*) -- *
  4 -> binaryOp div -- /
  5 -> binaryOp mod -- mod
  6 -> do
    -- dup
    stk <- gets stack
    case stk of
      x : _ -> modify $ \s -> s {stack = x : stk}
      [] -> throwError "Стек пуст для dup"
  7 -> do
    -- drop
    stk <- gets stack
    case stk of
      _ : xs -> modify $ \s -> s {stack = xs}
      [] -> throwError "Стек пуст для drop"
  8 -> do
    -- swap
    stk <- gets stack
    case stk of
      x : y : xs -> modify $ \s -> s {stack = y : x : xs}
      _ -> throwError "Недостаточно элементов для swap"
  9 -> do
    -- over
    stk <- gets stack
    case stk of
      x : y : xs -> modify $ \s -> s {stack = y : x : y : xs}
      _ -> throwError "Недостаточно элементов для over"
  10 -> do
    -- negate
    stk <- gets stack
    case stk of
      x : xs -> modify $ \s -> s {stack = (-x) : xs}
      [] -> throwError "Стек пуст для negate"
  11 -> do
    -- .
    stk <- gets stack
    case stk of
      x : xs -> do
        liftIO $ putStr (show x ++ " ")
        liftIO $ hFlush stdout
        modify $ \s -> s {stack = xs}
      [] -> throwError "Стек пуст для ."
  12 -> do
    -- .s
    stk <- gets stack
    liftIO $ putStrLn $ "<" ++ show (length stk) ++ "> " ++ unwords (map show stk)
    liftIO $ hFlush stdout
  13 -> liftIO $ putStrLn "До свидания!" >> exitSuccess -- bye
  where
    binaryOp :: (Int -> Int -> Int) -> ForthM ()
    binaryOp op = do
      stk <- gets stack
      case stk of
        x : y : xs -> modify $ \s -> s {stack = op y x : xs}
        _ -> throwError "Недостаточно элементов для бинарной операции"

testForth :: IO ()
testForth = do
  let testCases =
        [ "1 2 + .", -- 3
          "5 3 - .", -- 2
          "2 3 * .", -- 6
          "10 2 / .", -- 5
          "7 3 mod .", -- 1
          "5 dup . .", -- 5 5
          "1 2 swap . .", -- 1 2
          "1 2 over . . ." -- 1 2 1
        ]

  putStrLn "Запуск тестов:"
  mapM_ runTest testCases
  where
    runTest code = do
      putStrLn $ "Тест: " ++ code
      result <- runStateT (runExceptT (interpretProgram code)) initialState
      case result of
        (Left err, _) -> putStrLn $ "  Ошибка: " ++ err
        (Right _, state) -> putStrLn $ "  Стек: " ++ show (stack state)

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> do
      putStrLn "Выберите режим:"
      putStrLn "1 - Запуск тестов"
      putStrLn "2 - Выход"
      choice <- getLine
      case choice of
        "1" -> testForth
        "2" -> return ()
        _ -> putStrLn "Неверный выбор" >> main
    [filename] -> do
      program <- readFile filename
      putStrLn $ "Выполнение программы из файла: " ++ filename
      result <- runStateT (runExceptT (interpretProgram program)) initialState
      case result of
        (Left err, _) -> putStrLn $ "Ошибка: " ++ err
        (Right _, state) -> do
          putStrLn "Программа завершена."
          unless (null (stack state)) $
            putStrLn $
              "Стек: " ++ show (stack state)
    _ -> putStrLn "Использование: forth [файл.fth]"